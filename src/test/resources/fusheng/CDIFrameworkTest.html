<html>
<head>
    <meta charset="UTF-8"/>
    <title>CDI framework 使用说明</title>
</head>
<body>
<h3>概述</h3>
<div>CDI framework是一个简易版本的依赖注入框架，提供了一系列注解帮助用户声明需要自动注入的对象。</div>

<h3>详细介绍</h3>
<div>
    CDI framework 提供的注解包括以下几种：
    <ul>
        <li>@Inject</li>
        <li>@Named</li>
        <li>@Singleton</li>
    </ul>
</div>
<div class="example">
    <div>@Inject注解标识在属性上，框架会自动帮助我们将其引用接口的实现类注入到属性中。</div>
    <div>
        例如：我们有一个MovieLister类，该类有一个属性MovieFinder finder，MovieFinder接口有一个接口实现类为ColonDelimitedMovieFinder
        ，当我们在finder属性上使用注解@Inject时，容器将自动注入ColonDelimitedMovieFinder对象到finder上，listener执行all方法成功。
    </div>
<pre>
    class Main {
        public static void main (String[] args) {
            Container container = configureContainer();
            MovieListener listener = (MovieListener) container.getComponent(MovieListerInjectClassDependency.class);
            listener.all()
        }
    }
    class MovieListerInjectClassDependency {
        @Inject
        MovieFinderInterface finder;

        public void all() {
            finder.findAll();
        }
    }

    interface MovieFinderInterface {
        void findAll();
    }

    class ColonDelimitedMovieFinder implements MovieFinderInterface {
        @Override
        public void findAll() {
            System.out.println("findAll in ColonDelimitedMovieFinder");
        }
    }
</pre>
</div>

<div class="example">
    <div>当一个接口有多个实现类时，这时候仅仅通过Inject，框架将无法选择注入哪一个实现类。@Named注解可以帮助我们解决这个问题。</div>
    <div>首先，将@Named注解标识在实现类上，给实现类定义别名。</div>
    <div>然后，将@Named注解标识在需要依赖注入的属性上，即可实现通过别名注入对应的实现类</div>
    <div>
        例如：我们有一个MovieLister类，该类使用了@Inject注解注入MovieFinder，MovieFinder的接口实现类分别为ColonDelimitedMovieFinder
         和DatabaseMovieFinder，当我们在DatabaseMovieFinder类上使用@Named("database")注解给该实现定义别名，然后在MovieLister的属性
        注入时使用@Named("database")，容器将自动注入DatabaseMovieFinder对象到finder上，listener执行all方法成功。
    </div>
<pre>
    class Main {
        public static void main (String[] args) {
            Container container = configureContainer();
            MovieListener listener = (MovieListener) container.getComponent(MovieListerInjectClassDependency.class);
            listener.all()
        }
    }
    class MovieListerInjectClassDependency {
        @Inject
        @Named('database')
        MovieFinderInterface finder;

        public void all() {
            finder.findAll();
        }
    }

    interface MovieFinderInterface {
        void findAll();
    }

    class ColonDelimitedMovieFinder implements MovieFinderInterface {
        @Override
        public void findAll() {
            System.out.println("findAll in ColonDelimitedMovieFinder");
        }
    }

    @Named("database")
    class DatabaseMovieFinder implements MovieFinderInterface {
        @Override
        public void findAll() {
            System.out.println("findAll in DatabaseMovieFinder");
        }
    }
</pre>
</div>

<div class="example">
    <div>@Singleton注解标识在实现类上，表示这是一个单例对象，在当前应用中只存在一个。</div>
    <div>
        例如：我们有一个MovieLister类，该类有一个被@Inject注解标识的属性MovieFinder finder，MovieFinder接口有一个接口实现类为被@Singleton
        注解标识的ColonDelimitedMovieFinder，如果我们创建两个MovieLister实例，这两个对象的finder属性注入的将是同一个ColonDelimitedMovieFinder
        实例。
    </div>
<pre>
    class Main {
        public static void main (String[] args) {
            Container container = configureContainer();
            MovieListener listener1 = (MovieListener) container.getComponent(MovieListerInjectClassDependency.class);
            MovieListener listener2 = (MovieListener) container.getComponent(MovieListerInjectClassDependency.class);
            listener1.all();
            listener2.all();
            //验证lister1.finder.hashCode() == lister2.finder.hashCode()
        }
    }

    class MovieListerInjectClassDependency {
        @Inject
        MovieFinderInterface finder;

        public void all() {
            finder.findAll();
        }
    }


    interface MovieFinderInterface {
        void findAll();
    }

    @Singleton
    class ColonDelimitedMovieFinder implements MovieFinderInterface {
        @Override
        public void findAll() {
            System.out.println("findAll in ColonDelimitedMovieFinder");
        }
    }
</pre>
</div>

</body>
</html>